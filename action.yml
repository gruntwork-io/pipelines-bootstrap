name: Bootstrap Workflow
description: "Bootstrap workflows with common requirements"
inputs:
  token:
    description: "The GitHub token to use for checking out the infrastructure-live repo"
    required: true
  cache:
    description: "JSON Cache to use"
    required: false
    default: ""
  deploy_branch_name:
    description: "The name of the configured deploy branch"
    required: false
    default: main
  change_type:
    description: ""
    required: false
  branch:
    description: ""
    required: false
  working_directory:
    description: ""
    required: false
  account_id:
    description: ""
    required: false
  terragrunt_command:
    description: ""
    required: false
  additional_data:
    description: ""
    required: false
  child_account_id:
    description: ""
    required: false
  new_account_name:
    description: ""
    required: false
  team_account_names:
    description: ""
    required: false
  default_aws_region:
    description: "Where control tower is"
    required: true

outputs:
  gruntwork_config_file:
    description: "Absolute path to the .gruntwork/config.yml"
    value: ${{ steps.cache.outputs.gruntwork_config_file || steps.setup-action.outputs.gruntwork_config_file }}
  role_name:
    description: "The AWS role to assume"
    value: ${{ steps.cache.outputs.role_name || steps.get_role_name.outputs.role_name }}
  role_session_name:
    description: "The AWS Session name"
    value: ${{ steps.cache.outputs.role_session_name || steps.generate_role_session_name.outputs.role_session_name }}
  child_acct_role_name:
    description: "The AWS role to assume"
    value: ${{ steps.cache.outputs.child_acct_role_name || steps.get_role_name.outputs.child_acct_role_name }}
  pipelines_cli_version:
    description: "The version of the pipelines CLI to use"
    value: ${{ steps.cache.outputs.pipelines_cli_version || steps.infraLive.outputs.pipelines_cli_version }}
  terraform_version:
    description: "The version of Terraform that Gruntwork Pipelines will use"
    value: ${{ steps.cache.outputs.terraform_version || steps.infraLive.outputs.terraform_version }}
  terragrunt_version:
    description: "The version of Terragrunt that Gruntwork Pipelines will use"
    value: ${{ steps.cache.outputs.terragrunt_version || steps.infraLive.outputs.terragrunt_version }}
  admins:
    description: "The list of GitHub users that are allowed to use admin functionality in workflows"
    value: ${{ steps.cache.outputs.admins || steps.get_pipelines_admins.outputs.admins }}
  workflow:
    description: "The type of workflow to run in this job"
    value: ${{ steps.cache.outputs.workflow || steps.setup-action.outputs.workflow }}
  child_account_id:
    description: "The child account id to assume from `account_id`"
    value: ${{ steps.cache.outputs.child_account_id || steps.setup-action.outputs.child_account_id }}
  account_id:
    description: "The management account Id to use"
    value: ${{ steps.cache.outputs.account_id || steps.setup-action.outputs.account_id }}
  branch:
    description: "The branch we're operating on"
    value: ${{ steps.cache.outputs.branch || steps.setup-action.outputs.branch }}
  working_directory:
    description: "Where to run terragrunt"
    value: ${{ steps.cache.outputs.working_directory || steps.setup-action.outputs.working_directory }}
  terragrunt_command:
    description: "Terragrunt command to run e.g. plan/apply"
    value: ${{ steps.cache.outputs.terragrunt_command || steps.setup-action.outputs.terragrunt_command }}
  security_account_id:
    description: "AWS Account ID of the Security Account"
    value: ${{ steps.cache.outputs.security_account_id || steps.parse.outputs.security_account_id }}
  shared_account_id:
    description: "AWS Account ID of the Shared Account"
    value: ${{ steps.cache.outputs.shared_account_id || steps.parse.outputs.shared_account_id }}
  logs_account_id:
    description: "AWS Account ID of the Logs Account"
    value: ${{ steps.cache.outputs.logs_account_id || steps.parse.outputs.logs_account_id }}
  team_account_names:
    description: ""
    value: ${{ steps.cache.outputs.team_account_names || steps.setup-action.outputs.team_account_names }}
  new_account_name:
    description: ""
    value: ${{ steps.cache.outputs.new_account_name || steps.setup-action.outputs.new_account_name }}
  additional_data:
    description: ""
    value: ${{ steps.cache.outputs.additional_data || steps.setup-action.outputs.additional_data }}
  org_name_prefix:
    description: ""
    value: ${{ steps.cache.outputs.org_name_prefix || steps.account-request.outputs.org_name_prefix }}
  aws_region:
    description: ""
    value: ${{ steps.cache.outputs.aws_region || steps.account-request.outputs.aws_region }}
  requesting_team_name:
    description: ""
    value: ${{ steps.cache.outputs.requesting_team_name || steps.account-request.outputs.requesting_team_name }}
  account_baseline_modules_version:
    description: ""
    value: ${{ steps.cache.outputs.account_baseline_modules_version || steps.account-request.outputs.account_baseline_modules_version }}
  account_baseline_cis_service_catalog_version:
    description: ""
    value: ${{ steps.cache.outputs.account_baseline_cis_service_catalog_version || steps.account-request.outputs.account_baseline_cis_service_catalog_version }}
  create_vpc:
    description: ""
    value: ${{ steps.cache.outputs.create_vpc || steps.account-request.outputs.create_vpc }}
  tags:
    description: ""
    value: ${{ steps.cache.outputs.tags || steps.account-request.outputs.tags }}
  delegate_management:
    description: ""
    value: ${{ steps.cache.outputs.delegate_management || steps.account-request.outputs.delegate_management }}
  delegate_repo_name:
    description: ""
    value: ${{ steps.cache.outputs.delegate_repo_name || steps.account-request.outputs.delegate_repo_name }}
  default_aws_region:
    description: ""
    value: ${{ steps.cache.outputs.default_aws_region || steps.setup-action.outputs.default_aws_region }}
runs:
  using: composite
  steps:
    - name: Unpack and use cache
      id: cache
      shell: bash
      if: ${{ inputs.cache != '' }}
      run: |
        echo "gruntwork_config_file=${{ toJson(fromJson(inputs.cache).gruntwork_config_file) }}" >> "$GITHUB_OUTPUT"
        echo "role_name=${{ fromJson(inputs.cache).role_name }}" >> "$GITHUB_OUTPUT"
        echo "role_session_name=${{ fromJson(inputs.cache).role_session_name }}" >> "$GITHUB_OUTPUT"
        echo "child_acct_role_name=${{ fromJson(inputs.cache).child_acct_role_name }}" >> "$GITHUB_OUTPUT"
        echo "pipelines_cli_version=${{ fromJson(inputs.cache).pipelines_cli_version }}" >> "$GITHUB_OUTPUT"
        echo "terraform_version=${{ fromJson(inputs.cache).terraform_version }}" >> "$GITHUB_OUTPUT"


        echo "terragrunt_version=${{ fromJson(inputs.cache).terragrunt_version }}" >> "$GITHUB_OUTPUT"
        echo "admins=${{ fromJson(inputs.cache).admins }}" >> "$GITHUB_OUTPUT"
        echo "workflow=${{ fromJson(inputs.cache).workflow }}" >> "$GITHUB_OUTPUT"
        echo "child_account_id=${{ fromJson(inputs.cache).child_account_id }}" >> "$GITHUB_OUTPUT"
        echo "account_id=${{ fromJson(inputs.cache).account_id }}" >> "$GITHUB_OUTPUT"
        echo "branch=${{ fromJson(inputs.cache).branch }}" >> "$GITHUB_OUTPUT"


        echo "working_directory=${{ fromJson(inputs.cache).working_directory }}" >> "$GITHUB_OUTPUT"
        echo "terragrunt_command=${{ fromJson(inputs.cache).terragrunt_command }}" >> "$GITHUB_OUTPUT"
        echo "security_account_id=${{ fromJson(inputs.cache).security_account_id }}" >> "$GITHUB_OUTPUT"
        echo "shared_account_id=${{ fromJson(inputs.cache).shared_account_id }}" >> "$GITHUB_OUTPUT"
        echo "logs_account_id=${{ fromJson(inputs.cache).logs_account_id }}" >> "$GITHUB_OUTPUT"
        echo "team_account_names=${{ fromJson(inputs.cache).team_account_names }}" >> "$GITHUB_OUTPUT"


        echo "new_account_name=${{ fromJson(inputs.cache).new_account_name }}" >> "$GITHUB_OUTPUT"
        echo "additional_data=${{ fromJson(inputs.cache).additional_data }}" >> "$GITHUB_OUTPUT"
        echo "org_name_prefix=${{ fromJson(inputs.cache).org_name_prefix }}" >> "$GITHUB_OUTPUT"
        echo "aws_region=${{ fromJson(inputs.cache).aws_region }}" >> "$GITHUB_OUTPUT"
        echo "requesting_team_name=${{ fromJson(inputs.cache).requesting_team_name }}" >> "$GITHUB_OUTPUT"
        echo "account_baseline_modules_version=${{ fromJson(inputs.cache).account_baseline_modules_version }}" >> "$GITHUB_OUTPUT"


        echo "account_baseline_cis_service_catalog_version=${{ fromJson(inputs.cache).account_baseline_cis_service_catalog_version }}" >> "$GITHUB_OUTPUT"
        echo "create_vpc=${{ fromJson(inputs.cache).create_vpc }}" >> "$GITHUB_OUTPUT"
        echo "tags=${{ fromJson(inputs.cache).tags }}" >> "$GITHUB_OUTPUT"
        echo "delegate_management=${{ fromJson(inputs.cache).delegate_management }}" >> "$GITHUB_OUTPUT"
        echo "delegate_repo_name=${{ fromJson(inputs.cache).delegate_repo_name }}" >> "$GITHUB_OUTPUT"

        echo "default_aws_region=${{ fromJson(inputs.cache).default_aws_region }}" >> "$GITHUB_OUTPUT"
    - name: Setup Action
      id: setup-action
      if: ${{ inputs.cache == '' }}
      shell: bash
      env:
        CHANGE_TYPE: ${{ inputs.change_type }}
        BRANCH: ${{ inputs.branch }}
        WORKING_DIRECTORY: ${{ inputs.working_directory }}
        ACCOUNT_ID: ${{ inputs.account_id }}
        TERRAGRUNT_COMMAND: ${{ inputs.terragrunt_command }}
        ADDITIONAL_DATA: ${{ inputs.additional_data }}
        CHILD_ACCOUNT_ID: ${{ inputs.child_account_id }}
        NEW_ACCOUNT_NAME: ${{ inputs.new_account_name }}
        TEAM_ACCOUNT_NAMES: ${{ inputs.team_account_names }}
        DEFAULT_AWS_REGION: ${{ inputs.default_aws_region }}
      run: |
        case $CHANGE_TYPE in
          "AccountRequested")
            echo "workflow=create-account-and-generate-baselines.yml" >> "$GITHUB_OUTPUT"
            echo "new_account_name=$NEW_ACCOUNT_NAME" >> "$GITHUB_OUTPUT"
            ;;
          "AccountAdded")
            echo "workflow=apply-new-account-baseline.yml" >> "$GITHUB_OUTPUT"
            ;;
          "TeamAccountsRequested")
            echo "workflow=create-sdlc-accounts-and-generate-baselines.yml" >> "$GITHUB_OUTPUT"
            echo "team_account_names=$TEAM_ACCOUNT_NAMES" >> "$GITHUB_OUTPUT"
            ;;
          "TeamAccountsAdded")
            echo "workflow=apply-new-sdlc-accounts-baseline.yml" >> "$GITHUB_OUTPUT"
            echo "additional_data=$ADDITIONAL_DATA" >> "$GITHUB_OUTPUT"
            ;;
          *)
            echo "workflow=terragrunt-executor.yml" >> "$GITHUB_OUTPUT"
            ;;
            esac
          echo "child_account_id=$CHILD_ACCOUNT_ID" >> "$GITHUB_OUTPUT"
          echo "account_id=$ACCOUNT_ID" >> "$GITHUB_OUTPUT"
          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"
          echo "working_directory=$WORKING_DIRECTORY" >> "$GITHUB_OUTPUT"
          echo "terragrunt_command=$TERRAGRUNT_COMMAND" >> "$GITHUB_OUTPUT"
          echo "gruntwork_config_file=$(pwd)/.gruntwork/config.yml" >> "$GITHUB_OUTPUT"
          echo "default_aws_region=$DEFAULT_AWS_REGION" >> "$GITHUB_OUTPUT"

    - name: Generate role session name
      id: generate_role_session_name
      if: ${{ inputs.cache == '' }}
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        COMMIT_SHA: ${{ steps.setup-action.outputs.branch }}
        TG_CMD: ${{ steps.setup-action.outputs.terragrunt_command }}
      run: |
        if [[ $TG_CMD =~ ^(plan|run-all plan) ]]; then
          PR_SEARCH=$(gh pr list --search $COMMIT_SHA --json author --json mergedBy --json number --json baseRefName --json commits)

          if [[ $(echo $PR_SEARCH | jq '. == []') == 'true' ]]; then
            SESSION_REQUESTER="PullRequest"
            SESSION_GIT_REF=PR-$(git rev-parse --short ${COMMIT_SHA})
          else
            SESSION_REQUESTER=$(echo $PR_SEARCH | jq -r ".[0].commits[] | select(.oid == \"$COMMIT_SHA\") | .authors[0].login")
            SESSION_GIT_REF=PR-$(echo $PR_SEARCH | jq -r '.[0].number')
          fi
        else
          PR_SEARCH=$(gh pr list --search $COMMIT_SHA --json author --json mergedBy --json number --json baseRefName --json commits --state merged)
          SESSION_REQUESTER=$(echo $PR_SEARCH | jq -r '.[0].mergedBy.login')
          SESSION_GIT_REF=$(echo $PR_SEARCH | jq -r '.[0].baseRefName')
        fi

        echo "role_session_name=$SESSION_REQUESTER-via-GWPipelines@$SESSION_GIT_REF" >> $GITHUB_OUTPUT
    - name: Read infra-live's Gruntwork config file
      id: infraLive
      if: ${{ inputs.cache == '' }}
      shell: bash
      run: |
        config=$(cat .gruntwork/config.yml)

        # Initialize an array to store missing keys
        missing_keys=()

        get_pipelines_config() {
          local key=$1
          local yaml_key
          local value

          yaml_key=".pipelines.$key"
          value=$(echo "$config" | yq "$yaml_key")

          if [[ "$value" == "null" ]]; then
            missing_keys+=("$yaml_key")
          else
            echo "$value"
          fi
        }

        pipelines_cli_version=$(get_pipelines_config "cli-version")
        terraform_version=$(get_pipelines_config "terraform-version")
        terragrunt_version=$(get_pipelines_config "terragrunt-version")

        # Check if there are missing keys and error out if there are
        if [ ${#missing_keys[@]} -gt 0 ]; then
          missing_keys_str=$(IFS=,; printf "%s" "${missing_keys[*]}")
          echo "Error: The following keys do not exist in the YAML content: $missing_keys_str"
          exit 1
        fi

        echo "pipelines_cli_version=$pipelines_cli_version" >> "$GITHUB_OUTPUT"
        echo "terraform_version=$terraform_version" >> "$GITHUB_OUTPUT"
        echo "terragrunt_version=$terragrunt_version" >> "$GITHUB_OUTPUT"
    - name: Get AWS role names for Pipelines
      id: get_role_name
      if: ${{ inputs.cache == '' }}
      shell: bash
      env:
        TG_CMD: ${{ steps.setup-action.outputs.terragrunt_command }}
        ROLE_PREFIX: ${{ steps.setup-action.outputs.role_prefix }}
      run: |
        role_suffix="pipelines-plan"
        child_acct_role_name="pipelines-policy-plan-update"
        if ! [[ ${TG_CMD} =~ ^(plan|run-all plan) ]]; then
          role_suffix="pipelines-apply"
          child_acct_role_name="pipelines-policy-apply-update"
        fi

        role_name="$ROLE_PREFIX-$role_suffix"
        if [[ $INFRA_LIVE_REPO == $CENTRAL_INFRA_LIVE_REPO ]]; then
          role_name="central-$role_suffix"
        fi

        echo "role_name=$role_name" >>$GITHUB_OUTPUT
        echo "child_acct_role_name=$child_acct_role_name" >>$GITHUB_OUTPUT
    - name: Parse account IDs
      id: parse
      if: ${{ steps.setup-action.outputs.workflow != 'terragrunt-executor.yml' && inputs.cache == '' }}
      shell: bash
      run: |
        security_account_id="$(yq -r ".\"security\".id" "./accounts.yml")"
        echo "security_account_id=$security_account_id" >> $GITHUB_OUTPUT
        shared_account_id="$(yq -r ".\"shared\".id" "./accounts.yml")"
        echo "shared_account_id=$shared_account_id" >> $GITHUB_OUTPUT
        logs_account_id="$(yq -r ".\"logs\".id" "./accounts.yml")"
        echo "logs_account_id=$logs_account_id" >> $GITHUB_OUTPUT
    - name: "Read and parse new account request"
      id: account-request
      shell: bash
      if: ${{ inputs.cache == '' }}
      # Only try this if we've actually created the account
      env:
        NEW_ACCOUNT_NAME: ${{ inputs.new_account_name }}
      run: |
        request_file_path="./_new-account-requests/account-$NEW_ACCOUNT_NAME.yml"

        if [ -f "$request_file_path" ]; then
          org_name_prefix="$(yq -r ".org_name_prefix" "$request_file_path")"
          aws_region="$(yq -r ".aws_region" "$request_file_path")"
          requesting_team_name="$(yq -r ".requesting_team_name" "$request_file_path")"
          account_baseline_modules_version="$(yq -r ".account_baseline_modules_version" "$request_file_path")"
          account_baseline_cis_service_catalog_version="$(yq -r ".account_baseline_cis_service_catalog_version" "$request_file_path")"

          tags="$(yq -o=json -I=0 '.tags' "$request_file_path")"

          create_vpc="$(yq -r '.create_vpc' "$request_file_path")"

          # Handling edge case where account request file might not have a create_vpc field
          # We create one by default
          if [[ "$create_vpc" == "null" ]]; then
            create_vpc='true'
          fi

          delegate_management="$(yq -r '.delegate_management // false' "$request_file_path")"
          delegate_repo_name="$(yq -r '.delegate_repo_name // ""' "$request_file_path")"

          echo "org_name_prefix=$org_name_prefix" >> "$GITHUB_OUTPUT"
          echo "aws_region=$aws_region" >> "$GITHUB_OUTPUT"
          echo "requesting_team_name=$requesting_team_name" >> "$GITHUB_OUTPUT"
          echo "account_baseline_modules_version=$account_baseline_modules_version" >> "$GITHUB_OUTPUT"
          echo "account_baseline_cis_service_catalog_version=$account_baseline_cis_service_catalog_version" >> "$GITHUB_OUTPUT"
          echo "create_vpc=$create_vpc" >> "$GITHUB_OUTPUT"
          echo "tags=$tags" >> "$GITHUB_OUTPUT"
          echo "delegate_management=$delegate_management" >> "$GITHUB_OUTPUT"
          echo "delegate_repo_name=$delegate_repo_name" >> "$GITHUB_OUTPUT"
        else
          echo "No file found at $request_file_path - must not be a new account request workflow"
        fi
